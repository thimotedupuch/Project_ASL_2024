---
title: Project Part 4
date: today
subtitle: "Group 9"

authors:
  - name: Thimot√© Dupuch
    affiliation: University of Twente
    email: t.dupuch@student.utwente.nl
  - name: Joris van Lierop
    affiliation: University of Twente
    email: j.j.w.vanlierop@student.utwente.nl
  - name: Jurre van Sijpveld
    affiliation: University of Twente
    email: j.vansijpveld@student.utwente.nl

format:
    html:
        embed-resources: true
        df-print: paged
        monofont: monospace
        theme: zephyr
        highlight-style: github

toc: true
toc-depth: 3
toc-expand: true
toc-location: right
---

```{r}
#| output: false
library(tidyverse) # For data manipulation
library(knitr) # For tables
library(caret) # For model training
library(pROC) # For ROC analysis
library(MASS) # For stepAIC
library(boot) # For bootstrapping
library(survival) # For survival analysis
library(rms) # For validating Cox model
library(glmnet) # For lasso and ridge regression
library(data.table) # For faster CSV read
```


### Load dataset (and re-encode variables, not needed)
```{r}
Patients <- fread("SMARTc.csv", sep = ";")
final_patients <- Patients %>%
    mutate(log_CREAT = log(CREAT)) %>%
    subset(select = -c(HISTCARD, HISTCAR2, CREAT))
```


# Step 2: Cox model with stepwise selection

```{r}
#| output: false
surv_object <- Surv(time = final_patients$TEVENT, event = final_patients$EVENT)
surv_fit_formula <- surv_object ~ SEX + DIABETES + SYSTH + DIASTH + WEIGHT + BMI + LDL + TRIG + log_CREAT

initial_cox_model <- coxph(surv_fit_formula, data = final_patients)
stepwise_cox_model <- stepAIC(initial_cox_model, direction = "backward")
```

```{r}
summary(stepwise_cox_model)
```


# Step 5: Extracting coefficients from the final model

```{r}
final_coefficients <- coef(stepwise_cox_model)
print(final_coefficients)
```



# Step 6: Calculate concordance index for the final model

```{r}
final_surv <- Surv(time = final_patients$TEVENT, event = final_patients$EVENT)
final_surv_fit_formula <- final_surv ~ predict(stepwise_cox_model, newdata = final_patients)
final_cox_model <- coxph(final_surv_fit_formula, data = final_patients)
concordance_index <- final_cox_model$concordance
print(paste("Concordance Index:", concordance_index))
```

# Step 7: Summary of the final model and exponentiated coefficients
```{r}
summary(final_cox_model)
exp(final_coefficients)
```

# Step 8: Cross-validation of the Cox model

```{r}
#| output: false
set.seed(123)
folds <- createFolds(final_patients$EVENT, k = 10, list = TRUE, returnTrain = TRUE)
cv_concordance_indices <- numeric(10)

for (i in 1:10) {
    # Split the data into training and testing sets
    train_data <- final_patients[folds[[i]], ]
    test_data <- final_patients[-folds[[i]], ]

    # Create the survival object for training data
    surv_train <- Surv(time = train_data$TEVENT, event = train_data$EVENT)
    surv_fit_formula <- surv_train ~ SEX + DIABETES + SYSTH + DIASTH + WEIGHT + BMI + LDL + TRIG + log_CREAT

    # Fit the Cox model on the training data
    cox_model <- coxph(surv_fit_formula, data = train_data)

    # Predict on the test data
    test_surv <- Surv(time = test_data$TEVENT, event = test_data$EVENT)
    predictions <- predict(cox_model, newdata = test_data)

    cv_concordance_indices[i] <- coxph(test_surv ~ predictions, data = test_data)$concordance
}

mean_concordance_cv <- mean(cv_concordance_indices)
mean_concordance_cv
```

```{r}
#| output: false
bootstrap_cox_model <- function(data, indices) {
    resampled_data <- data[indices, ]
    surv_object <- Surv(time = resampled_data$TEVENT, event = resampled_data$EVENT)
    surv_fit_formula <- surv_object ~ SEX + DIABETES + SYSTH + DIASTH + WEIGHT + BMI + LDL + TRIG + log_CREAT

    initial_cox_model <- coxph(surv_fit_formula, data = resampled_data)
    stepwise_model <- stepAIC(initial_cox_model, direction = "backward", trace = FALSE)
    all_vars <- colnames(data)[-c(1, 2)]
    selected_vars <- names(coef(stepwise_model))

    # Create a binary vector: 1 if the variable is included, 0 otherwise
    inclusion_vector <- as.integer(all_vars %in% selected_vars)

    return(inclusion_vector)
}

# Set the number of bootstrap samples
set.seed(123)
n_bootstrap_samples <- 100

# Run bootstrapping
bootstrap_results <- boot(data = final_patients, statistic = bootstrap_cox_model, R = n_bootstrap_samples)
```


# Analyze results: Create a table of inclusion frequencies

```{r}
inclusion_frequencies <- colMeans(bootstrap_results$t) # Get inclusion proportions
inclusion_variables <- colnames(final_patients)[-c(1, 2)]
inclusion_frequencies <- data.frame(Variable = inclusion_variables, Proportion = inclusion_frequencies)
inclusion_frequencies
```


# Optional: Visualize the inclusion frequencies

```{r}
ggplot(inclusion_frequencies, aes(x = reorder(Variable, -Proportion), y = Proportion)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    labs(
        title = "Variable Inclusion Frequencies in Bootstrapped Cox Models",
        x = "Predictor Variables",
        y = "Proportion of Inclusion"
    ) +
    theme_minimal()
```